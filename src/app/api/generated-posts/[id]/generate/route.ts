/**
 * Custom API Endpoint: Generate AI Content for GeneratedPost
 * POST /api/generated-posts/{id}/generate
 */

import configPromise from '@payload-config'
import { getPayload } from 'payload'
import { NextRequest, NextResponse } from 'next/server'
import { withErrorHandling, ErrorResponses, createSuccessResponse } from '@/middleware/error-handling'
import { withRateLimit, RateLimitConfigs } from '@/middleware/rate-limiting'
import { withValidation } from '@/middleware/api-validation'

async function handleGenerate(req: NextRequest, { params }: { params: { id: string } }) {
  if (req.method !== 'POST') {
    return ErrorResponses.badRequest('Only POST method is allowed', undefined, req.url)
  }

  const payload = await getPayload({ config: configPromise })
  const { id } = params

  // Get request body
  let body: { writingStyle?: string; referencePostId?: string } = {}
  try {
    body = await req.json()
  } catch {
    // Body is optional for this endpoint
  }

  // Find the generated post
  const generatedPost = await payload.findByID({
    collection: 'generated-posts',
    id,
  })

  if (!generatedPost) {
    return ErrorResponses.notFound('Generated post not found', req.url)
  }

  // Update writing style if provided
  if (body.writingStyle) {
    const validStyles = ['story_based', 'insight_focused', 'engagement_focused']
    if (!validStyles.includes(body.writingStyle)) {
      return ErrorResponses.badRequest(
        `Invalid writingStyle. Must be one of: ${validStyles.join(', ')}`,
        undefined,
        req.url
      )
    }
  }

  // If referencePostId is provided, link it
  if (body.referencePostId) {
    try {
      const referencePost = await payload.findByID({
        collection: 'reference-posts',
        id: body.referencePostId,
      })

      if (!referencePost) {
        return ErrorResponses.notFound('Reference post not found', req.url)
      }

      // Update generated post with reference
      await payload.update({
        collection: 'generated-posts',
        id,
        data: {
          referencePost: body.referencePostId,
          writingStyle: (body.writingStyle as any) || generatedPost.writingStyle,
          status: 'draft', // Reset to draft when regenerating
        },
      })
    } catch (error) {
      return ErrorResponses.badRequest('Invalid referencePostId', undefined, req.url)
    }
  } else if (body.writingStyle) {
    // Only update writing style
    await payload.update({
      collection: 'generated-posts',
      id,
      data: {
        writingStyle: body.writingStyle as any,
        status: 'draft',
      },
    })
  }

  // Fetch updated post
  const updatedPost = await payload.findByID({
    collection: 'generated-posts',
    id,
    depth: 2, // Include related data
  })

  // Note: Actual AI content generation would be triggered by n8n workflow
  // This endpoint just prepares the post for generation

  return createSuccessResponse(updatedPost, 200, {
    message: 'Post prepared for AI content generation. Content will be generated by n8n workflow.',
  })
}

// Wrap with middleware
export const POST = withRateLimit(
  withErrorHandling(
    withValidation(handleGenerate, {
      bodySchema: {
        properties: {
          writingStyle: {
            type: 'string',
            enum: ['story_based', 'insight_focused', 'engagement_focused'],
          },
          referencePostId: {
            type: 'string',
          },
        },
      },
    })
  ),
  RateLimitConfigs.standard
)

