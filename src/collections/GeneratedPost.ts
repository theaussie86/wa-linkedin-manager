import type { CollectionConfig } from 'payload'
import { linkedinPostIdValidator, linkedinPostUrlValidator } from '../utils/linkedin'
import { triggerContentGeneration } from '../services/n8n/webhook-client'

export const GeneratedPost: CollectionConfig = {
  slug: 'generated-posts',
  admin: {
    useAsTitle: 'title',
    defaultColumns: ['title', 'company', 'writingStyle', 'status', 'scheduledFor', 'publishedAt'],
  },
  access: {
    read: ({ req: { user } }) => {
      if (user?.role === 'admin') return true
      if (user?.role === 'manager') return true
      if (!user?.company) {
        return false // User has no company assigned
      }
      return {
        and: [
          {
            company: {
              equals: typeof user.company === 'string' ? user.company : user.company.id,
            },
          },
          {
            status: {
              not_equals: 'draft', // Don't show drafts to non-admin users unless they created them
            },
          },
        ],
      }
    },
    create: ({ req: { user } }) => {
      return user?.role === 'admin' || user?.role === 'manager' || user?.role === 'content_creator'
    },
    update: ({ req: { user } }) => {
      if (user?.role === 'admin') return true
      if (user?.role === 'manager') return true
      if (user?.role === 'reviewer') return true // Reviewers can update for review purposes
      if (!user?.company) {
        return false // User has no company assigned
      }
      // Content creators can only update their own draft posts
      if (user?.role === 'content_creator') {
        return {
          and: [
            {
              company: {
                equals: typeof user.company === 'string' ? user.company : user.company.id,
              },
            },
            {
              status: {
                equals: 'draft',
              },
            },
          ],
        }
      }
      return {
        company: {
          equals: typeof user.company === 'string' ? user.company : user.company.id,
        },
      }
    },
    delete: ({ req: { user } }) => {
      return user?.role === 'admin' || user?.role === 'manager'
    },
  },
  fields: [
    {
      name: 'company',
      type: 'relationship',
      relationTo: 'companies',
      required: true,
    },
    {
      name: 'referencePost',
      type: 'relationship',
      relationTo: 'reference-posts',
    },
    {
      name: 'title',
      type: 'text',
      required: true,
    },
    {
      name: 'content',
      type: 'richText',
      required: true,
    },
    {
      name: 'writingStyle',
      type: 'select',
      required: true,
      options: [
        { label: 'Story Based', value: 'story_based' },
        { label: 'Insight Focused', value: 'insight_focused' },
        { label: 'Engagement Focused', value: 'engagement_focused' },
      ],
    },
    {
      name: 'category',
      type: 'select',
      required: true,
      options: [
        { label: 'Thought Leadership', value: 'thought_leadership' },
        { label: 'Industry Insights', value: 'industry_insights' },
        { label: 'Company Updates', value: 'company_updates' },
        { label: 'Educational', value: 'educational' },
        { label: 'Behind the Scenes', value: 'behind_scenes' },
        { label: 'Case Studies', value: 'case_studies' },
      ],
    },
    {
      name: 'status',
      type: 'select',
      options: [
        { label: 'Draft', value: 'draft' },
        { label: 'Review', value: 'review' },
        { label: 'Approved', value: 'approved' },
        { label: 'Scheduled', value: 'scheduled' },
        { label: 'Published', value: 'published' },
        { label: 'Rejected', value: 'rejected' },
      ],
      defaultValue: 'draft',
    },
    {
      name: 'aiPrompt',
      type: 'textarea',
      admin: {
        description: 'AI prompt used for generation',
      },
    },
    {
      name: 'aiModel',
      type: 'text',
      admin: {
        description: 'AI model used for generation',
      },
    },
    {
      name: 'generatedAt',
      type: 'date',
      admin: {
        description: 'When this post was generated by AI',
      },
    },
    {
      name: 'reviewedBy',
      type: 'relationship',
      relationTo: 'users',
      admin: {
        description: 'User who reviewed this post',
      },
    },
    {
      name: 'reviewComments',
      type: 'textarea',
      admin: {
        description: 'Comments from the reviewer',
      },
    },
    {
      name: 'reviewedAt',
      type: 'date',
      admin: {
        description: 'When this post was reviewed',
      },
    },
    {
      name: 'scheduledFor',
      type: 'date',
      admin: {
        description: 'When this post is scheduled to be published',
      },
    },
    {
      name: 'publishedAt',
      type: 'date',
      admin: {
        description: 'When this post was actually published',
      },
    },
    {
      name: 'linkedinPostId',
      type: 'text',
      validate: linkedinPostIdValidator,
      admin: {
        description: 'LinkedIn Post ID (numeric, set after publication)',
      },
    },
    {
      name: 'linkedinPublicationUrl',
      type: 'text',
      validate: linkedinPostUrlValidator,
      admin: {
        description: 'Full LinkedIn post URL after publication',
      },
    },
    {
      name: 'linkedinPublicationDate',
      type: 'date',
      admin: {
        description: 'Date when the post was published on LinkedIn',
      },
    },
    {
      name: 'images',
      type: 'array',
      fields: [
        {
          name: 'image',
          type: 'upload',
          relationTo: 'media',
        },
      ],
    },
    {
      name: 'tags',
      type: 'array',
      fields: [
        {
          name: 'tag',
          type: 'text',
        },
      ],
    },
    {
      name: 'performance',
      type: 'relationship',
      relationTo: 'post-analytics',
      hasMany: true,
      admin: {
        description: 'Performance analytics for this post',
      },
    },
  ],
  timestamps: true,
  hooks: {
    beforeValidate: [
      ({ data, operation }) => {
        // Normalize title
        if (data?.title) {
          data.title = data.title.trim()
        }
        // Ensure status defaults to draft on create
        if (operation === 'create' && !data?.status) {
          data.status = 'draft'
        }
        return data
      },
    ],
    beforeChange: [
      async ({ data, operation, req, doc }) => {
        // Status transition validation
        if (operation === 'update' && data.status && doc) {
          const previousStatus = doc.status
          const newStatus = data.status

          const validTransitions: Record<string, string[]> = {
            draft: ['review', 'rejected'],
            review: ['approved', 'rejected', 'draft'],
            approved: ['scheduled', 'draft'],
            scheduled: ['published', 'draft'],
            published: [], // Terminal state - cannot transition from published
            rejected: ['draft'],
          }

          if (previousStatus && validTransitions[previousStatus]) {
            if (!validTransitions[previousStatus].includes(newStatus)) {
              throw new Error(
                `Invalid status transition from ${previousStatus} to ${newStatus}. Valid transitions: ${validTransitions[previousStatus].join(', ')}`,
              )
            }
          }

          // Update reviewedBy and reviewedAt when status changes to approved/rejected
          if (newStatus === 'approved' || newStatus === 'rejected') {
            if (!data.reviewedBy && req.user) {
              data.reviewedBy = typeof req.user === 'string' ? req.user : req.user.id
            }
            if (!data.reviewedAt) {
              data.reviewedAt = new Date().toISOString()
            }
          }

          // Update publishedAt when status changes to published
          if (newStatus === 'published' && !data.publishedAt) {
            data.publishedAt = new Date().toISOString()
          }

          // Update linkedinPublicationDate when status changes to published
          if (newStatus === 'published' && !data.linkedinPublicationDate) {
            data.linkedinPublicationDate = new Date().toISOString()
          }
        }

        // Scheduled date validation
        if (data.scheduledFor) {
          const scheduledDate = new Date(data.scheduledFor)
          const now = new Date()
          if (scheduledDate < now && data.status === 'scheduled') {
            throw new Error('Scheduled date must be in the future')
          }
        }

        // Set generatedAt when AI content is created
        if (data.aiModel && !data.generatedAt && operation === 'create') {
          data.generatedAt = new Date().toISOString()
        }

        return data
      },
    ],
    afterChange: [
      async ({ doc, req, operation }) => {
        // Log generated post creation/update
        if (operation === 'create') {
          req.payload.logger.info(`New generated post created: ${doc.title} (${doc.id}) - Status: ${doc.status}`)
        } else if (operation === 'update') {
          req.payload.logger.info(`Generated post updated: ${doc.title} (${doc.id}) - Status: ${doc.status}`)

          // Trigger n8n Content Generation Workflow when status is 'draft' and content is empty
          // Condition: status === 'draft' AND content is empty AND operation === 'update'
          if (doc.status === 'draft' && operation === 'update') {
            // Check if content is empty
            const isContentEmpty = 
              !doc.content ||
              !doc.content.root ||
              !doc.content.root.children ||
              doc.content.root.children.length === 0 ||
              doc.content.root.children.every((child: any) => {
                // Check if paragraph/list/heading nodes are empty
                if (child.type === 'paragraph' || child.type === 'heading') {
                  return !child.children || child.children.length === 0 || 
                    child.children.every((c: any) => !c.text || c.text.trim() === '')
                }
                if (child.type === 'list') {
                  return !child.children || child.children.length === 0
                }
                return true
              })

            if (isContentEmpty) {
              // Optional: Check for manual trigger flag (generateImage from request data)
              // For now, default to generateImage: false
              const generateImage = false

              // Async execution: fire-and-forget, non-blocking
              triggerContentGeneration(String(doc.id), generateImage, req.payload).catch((error) => {
                req.payload.logger.error(
                  `Failed to trigger content generation webhook for post ${doc.id}`,
                  { error, generatedPostId: doc.id, generateImage },
                )
              })
            }
          }
        }
      },
    ],
    beforeDelete: [
      async ({ id, req }) => {
        // Soft delete: Log deletion request
        req.payload.logger.warn(`Soft delete requested for generated post ${id} - use update to set status=rejected or remove instead`)
      },
    ],
  },
}
